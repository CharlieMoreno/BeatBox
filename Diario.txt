15/01/2018	Apuntada la conexión de pines del MPU6050 y del HC-05 en el programa BeatBox.cpp.

				* Comprobar funcionamiento de getRealTrigger().	[DONE]
				* Idem para recordTaps().
				* Darle una pensada a la cuantización. Ya tengo una idea en mente.

16/01/2018	No funciona la subida a Arduino. Puede que estén jodidos los controladores de los puertos COM. [SOLVED]

17/01/2018	En el Administrador de Dispositivos he visto que el controlador del COM3 está mal, y no lo he podido solucionar.
			He reconfigurado el AVRdude en el AtmelStudio (Tools > External Tools...) para que use el puerto COM4. [FUNCIONA]
			(El COM4 es el puerto USB de la izquierda más cerca de la pantalla)

			getRealTrigger() no funciona bien con las últimas modificaciones. Con cada golpe, por el monitor serie se muestra
			el eje X+ con los las lecturas de cada eje nulas. El momento de la reinicialización a cero de los axisTriggerValues
			no debe de ser adecuado. Antes creo recordar que estaba fuera, en loop(), después de imprimir el resultado por
			el monitor serie. Dale una pensada al flujo del código. [SOLVED]
		  
22/01/2018	Acabo de percatarme de que el struct Trigger está formado casi totalmente por integers, de modo que todos los 
			resultados de los cálculos efectuados en updateTrigger() son truncados. ¿Podría ser un inconveniente? Por el 
			momento, no parece, pero dejo la questión en el aire.

			He movido la reinicialización de los axisTriggerValues al final de getRealTrigger(). Ahora ya funciona bien. Yuhu!

23/01/2018	Tengo que añadir alguna condición para que la parte de grabación de taps de recordTaps() no grabe el mismo tap
			como uno nuevo en cada vuelta de loop(). Tal vez podría separar la "Configuración de beatLength y Compás" y la
			"Grabación de Taps" en dos funciones, y poner esta última en getRealTrigger(). Incluso sin estar en una función. 
			A cholón. Simplificaría cosas de argumentos y tal... o no. Check it out.
			[09/06/2018 EDIT]: He vuelto a examinar el código buscando este comportamiento y me ha parecido que no ocurre.

20/05/2018	Creo que me rayé cuando escribí la anterior entrada. Con cada impacto, sólo hay una vuelta de loop en la que 
			el valor de maxTriggerAxis es distinto a -1, de modo que sólo se graba un tap.

04/06/2018	Esta semana he estado intentando importar a Atmel Studio un ejemplo de arduino que usa el Sparkfun Razor, pero ha sido en vano.
		    No he conseguido terminar de solucionar los fallos que da, aunque voy a dejar aquí apuntados los paths de algunas
			librerías necesarias para la importación:
	
			sam.h 	--> C:\Users\Charlie\AppData\Local\Arduino15\packages\arduino\tools\CMSIS-Atmel\1.1.0\CMSIS\Device\ATMEL
			Wire.h 	--> C:\Program Files (x86)\Arduino\hardware\arduino\avr\libraries\Wire\src

06/06/2018	Intensa tarde de porting con Yago. Hemos conseguido que el proyecto compile en Arduino IDE con la Sparkfun Razor, aunque claro,
			ahora toca calibrar el acelerómetro y reajustar todos los parámetros necesarios para que se detecten los golpes.
			Está en esta ubicación: C:\Users\Charlie\Documents\Arduino\BeatBox4\BeatBox4\BeatBoxArd
			  
			A partir de esta versión de Arduino, lo hemos importado a Atmel Studio 7. Para ello, hemos tenido que examinar el output de compilación del Arduino IDE
			y apuntar las ubicaciones que incluye, que son las siguientes:
			
				Del Arduino Core:
				C:\Users\Charlie\AppData\Local\Arduino15\packages\arduino\tools\CMSIS\4.5.0/CMSIS/Include/
				C:\Users\Charlie\AppData\Local\Arduino15\packages\arduino\tools\CMSIS-Atmel\1.1.0/CMSIS/Device/ATMEL/
				C:\Users\Charlie\AppData\Local\Arduino15\packages\SparkFun\hardware\samd\1.4.0\cores\arduino
				C:\Users\Charlie\AppData\Local\Arduino15\packages\SparkFun\hardware\samd\1.4.0\libraries\Wire
		
				Específicas de la aplicación:
				C:\Users\Charlie\AppData\Local\Arduino15\packages\SparkFun\hardware\samd\1.4.0\variants\SparkFun_9DoF_M0
				C:\Users\Charlie\Documents\Arduino\libraries\SparkFun_MPU-9250-DMP_Arduino_Library-master\src
				
			He añadido todas ellas a través de Propiedades(Solution explorer) > Toolchain > Directories > C Compiler y C++ Compiler.
			Después creo recordar que hubo que añadir al árbol de carpetas algunos archivos, pero ya no recuerdo cuáles. En cualquier caso, eran los que el 
			compilador iba diciendo que le faltaban.
			
			Después hemos añadido un programador nuevo en External Tools basado en bossac.exe, siguiendo las instrucciones de esta página:
			http://www.elecrom.com/program-arduino-due-atmel-studio/
			
			El problema es que tras cargar el programa en el micro, el puerto COM desaparece, por lo que no se puede usar el monitor serie.
			Hemos dejado las opciones  del programador iguales a las del Arduino IDE, pero sin éxito. Hemos concluído que debe de haber algún
			parámetro distinto en algún sitio que hace que no se mantenga o reabra el puerto COM. 
			
09/06/2018	He decidido ponerme con el setup del MPU6050 y Arduino Mega para avanzar con el software.			

10/06/2018	No va mal la cosa. Parece que funciona la definción de tempo y compás, el metrónomo, la grabación de taps y su reproducción en loop. 

12/06/2018	He abordado el problema de la cuantización añadiendo mediante 'or' una condición adicional para incluir en el uno del compás los taps que	
			están pegados a este por detrás, o lo que es lo mismo, al final del compás. No he comprobado si funciona.

14/06/2018	Me he descargado hairlessMIDI y loopMIDI para poder leer los mensajes MIDI del puerto serie y
			para enviarlos a un puerto MIDI virtual al que pueda conectarse una aplicación como Ableton Live.
			
			No están llegando correctamente los bytes del metrónomo, según hairlessMIDI.
			
16/06/2018	Por fin llegan correctamente los paquetes MIDI al PC. El problema ahora es la latencia, que además parece ser función del mensaje enviado, 
			porque entre el 4 y el 1 del metrónomo transcurre menos tiempo que entre los otros beats. 
			
			La librería MIDIUSB de Arduino al parecer usa una función llamada flush() tras cada envío de mensaje para que dicho envío sea inmediato, 
			ya que si no, y cito cuasi textualmente, al no ser USB un sistema de tiempo real, llegaría cada mensaje cuando le diera la gana, dicho rápido y mal.
			El problema es que, al parecer, esta librería no soporta la Arduino Mega.
			
			He descargado otra librería llamada MIDI y los paquetes parece que los manda bien distribuidos en el tiempo. El problema es que en el código se mandan notas,
			y el monitor del Hairless muestra mensajes de cambio de programa. Así que un pan como unas hostias. No he conseguido averiguar por qué.
			
			Me he puesto con el Bluetooth. He conseguido emparejar el módulo HC-05 que no está envuelto en plástico. He tenido que agregarlo desde la configuración
			de bluetooth de Windows. 
			
			Si parpadea rápido, es que está esperando a ser conectado.
			Si parpadea despacio a intervalos iguales entre  encendido y apagado, es que está en modo de configuración AT.
			Si parpadea dos veces seguidas y se espera un par de segundos, es que está conectado.
			
			He conseguido que se comuniquen! Voy a describir el setup:
			
				Utilizo el módulo HC-05 que no está plastificado.
				
				VCC está conectado a los 5V del Arduino Mega, GND a GND, el TX al PIN 51 y el RX a un divisor de tensión, desde cuyo nodo
				por un lado sale una resistencia de 680K a GND y, por otro, una de 330K al PIN 3 del Arduino Mega. Esto ha de hacerse así
				para que el pin RX del HC-05 reciba 3,3V. Si recibiese 5V, que es lo que suministran los pines de la placa, se acabaría jodiendo. 
				Además, ha empezado a funcionar la comunicación cuando he montado el divisor de tensión.
				
				El sketch de Arduino utilizado es el llamado "Sketch_prueba_HC05_bluetooth.ino" en 
				C:\Users\Charlie\Documents\ETSII_UPM\TFG\Bluetooth\HC-05 FUNCIONAL\Sketch_prueba_HC05_bluetooth
				Voy a subirlo a GitHub para tener un backup: C:\Users\Charlie\Documents\GitHub\BeatBox\HC-05 FUNCIONAL\Sketch_prueba_HC05_bluetooth
				Los baudrate del puerto serie y bluetooth son 9600 baud.
				
				En el PuTTY está guardada la configuración bajo el nombre "Arduino". Usa el puerto COM9 (consultado en el administrador de dispositivos, 
				en el que se ve por cierto que también se levanta el puerto COM10 para el HC-05, pero no he conseguido conectarme por ese) y una velocidad
				de 9600 baud.
				
				Para configurar el HC-05, le quito VCC, pulso el botoncito que tiene y vuelvo a poner VCC. Cargo en la MEGA el sketch "Config_HC-05", 
				en C:\Users\Charlie\Documents\GitHub\BeatBox\HC-05 FUNCIONAL\Config_HC-05
				El baudrate del puerto serie con el HC-05 debe ser 38400 baud.
				Al escribir en el monitor serie "at+uart?" devuelve por defecto "9600,0,0", siendo estos dos últimos números el stop bit y el parity bit.
				He escrito "at+uart=115200,0,0" para cambiarle la velocidad del puerto serie a 115200 baud.
				Los comandos AT vienen descritos en "Comandos AT.pdf", en C:\Users\Charlie\Documents\GitHub\BeatBox\HC-05 FUNCIONAL.
				

